name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (build without creating release)'
        required: false
        type: boolean
        default: true

env:
  CARGO_TERM_COLOR: always
  SCCACHE_GHA_ENABLED: "true"
  RUSTC_WRAPPER: "sccache"

jobs:
  create-release:
    if: github.event_name == 'push' && github.ref_type == 'tag'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "Usage Indicator ${{ github.ref_name }}"
          body: "See CHANGELOG.md for details."
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    needs: [create-release]
    if: always() && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    name: Build (${{ matrix.target.os }} / ${{ matrix.target.arch }})
    runs-on: ${{ matrix.target.runner }}
    permissions:
      contents: write
      id-token: write
      attestations: write
    strategy:
      fail-fast: false
      matrix:
        target:
          - os: linux
            arch: x86_64
            runner: ubuntu-22.04
            rust_target: x86_64-unknown-linux-gnu
            bundles: appimage
          - os: macos
            arch: x86_64
            runner: macos-13
            rust_target: x86_64-apple-darwin
            bundles: dmg
          - os: macos
            arch: aarch64
            runner: macos-latest
            rust_target: aarch64-apple-darwin
            bundles: dmg
          - os: windows
            arch: x86_64
            runner: windows-latest
            rust_target: x86_64-pc-windows-msvc
            bundles: msi,nsis
          - os: windows
            arch: aarch64
            runner: windows-latest
            rust_target: aarch64-pc-windows-msvc
            bundles: msi,nsis

    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
          targets: ${{ matrix.target.rust_target }}

      - name: Run sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          key: ${{ matrix.target.rust_target }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install frontend dependencies
        run: bun install --frozen-lockfile

      - name: Cache Linux dependencies
        if: matrix.target.os == 'linux'
        uses: awalsh128/cache-apt-pkgs-action@v1.6.0
        with:
          packages: build-essential libglib2.0-dev libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf
          version: 1.0

      - name: Build Tauri app
        id: tauri-build
        uses: tauri-apps/tauri-action@v0.5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          args: --target ${{ matrix.target.rust_target }} --bundles ${{ matrix.target.bundles }}

      - name: Rename artifacts with consistent naming
        shell: bash
        run: |
          # In dry-run mode (workflow_dispatch), use version from package.json
          # In release mode (tag push), use the tag name
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="v$(grep -Po '"version": "\K[^"]*' package.json)"
          else
            VERSION="${{ github.ref_name }}"
          fi

          OS="${{ matrix.target.os }}"
          ARCH="${{ matrix.target.arch }}"
          BUNDLE_DIR="src-tauri/target/${{ matrix.target.rust_target }}/release/bundle"

          # Set platform name for files
          case "$OS" in
            linux) PLATFORM="linux" ;;
            macos) PLATFORM="macOS" ;;
            windows) PLATFORM="windows" ;;
          esac

          # Track renamed files for upload
          RENAMED_FILES=()

          # Linux: AppImage
          if [ "$OS" = "linux" ]; then
            APPIMAGE=$(find "$BUNDLE_DIR/appimage" -name "*.AppImage" -type f 2>/dev/null | head -n 1)
            if [ -f "$APPIMAGE" ]; then
              NEW_NAME="usage-indicator-${VERSION}-${PLATFORM}-${ARCH}.AppImage"
              cp "$APPIMAGE" "$NEW_NAME"
              RENAMED_FILES+=("$NEW_NAME")
              if [ -f "${APPIMAGE}.sig" ]; then
                cp "${APPIMAGE}.sig" "${NEW_NAME}.sig"
                RENAMED_FILES+=("${NEW_NAME}.sig")
              fi
            fi
          fi

          # macOS: DMG
          if [ "$OS" = "macos" ]; then
            DMG=$(find "$BUNDLE_DIR/dmg" -name "*.dmg" -type f 2>/dev/null | head -n 1)
            if [ -f "$DMG" ]; then
              NEW_NAME="usage-indicator-${VERSION}-${PLATFORM}-${ARCH}.dmg"
              cp "$DMG" "$NEW_NAME"
              RENAMED_FILES+=("$NEW_NAME")
            fi
          fi

          # Windows: MSI and NSIS
          if [ "$OS" = "windows" ]; then
            # NSIS installer
            NSIS=$(find "$BUNDLE_DIR/nsis" -name "*-setup.exe" -type f 2>/dev/null | head -n 1)
            if [ -f "$NSIS" ]; then
              NEW_NAME="usage-indicator-${VERSION}-${PLATFORM}-${ARCH}.exe"
              cp "$NSIS" "$NEW_NAME"
              RENAMED_FILES+=("$NEW_NAME")
              if [ -f "${NSIS}.sig" ]; then
                cp "${NSIS}.sig" "${NEW_NAME}.sig"
                RENAMED_FILES+=("${NEW_NAME}.sig")
              fi
            fi

            # MSI installer
            MSI=$(find "$BUNDLE_DIR/msi" -name "*.msi" -type f 2>/dev/null | head -n 1)
            if [ -f "$MSI" ]; then
              NEW_NAME="usage-indicator-${VERSION}-${PLATFORM}-${ARCH}.msi"
              cp "$MSI" "$NEW_NAME"
              RENAMED_FILES+=("$NEW_NAME")
              if [ -f "${MSI}.sig" ]; then
                cp "${MSI}.sig" "${NEW_NAME}.sig"
                RENAMED_FILES+=("${NEW_NAME}.sig")
              fi
            fi
          fi

          # Handle latest.json
          UPDATER_JSON="$BUNDLE_DIR/../latest.json"
          if [ -f "$UPDATER_JSON" ]; then
            # Update file paths in latest.json to match renamed files
            VERSION_NO_V="${VERSION#v}"  # Remove 'v' prefix

            # Read and update the JSON with proper file name replacements
            # We need to update the URLs to use the new naming scheme while preserving extensions
            cp "$UPDATER_JSON" "latest.json.tmp"

            # Update URLs based on platform-specific patterns
            if [ "$OS" = "windows" ]; then
              sed -i.bak \
                -e "s|usage-indicator_${VERSION_NO_V}_x64-setup\.exe|usage-indicator-${VERSION}-${PLATFORM}-x86_64.exe|g" \
                -e "s|usage-indicator_${VERSION_NO_V}_x64_en-US\.msi|usage-indicator-${VERSION}-${PLATFORM}-x86_64.msi|g" \
                -e "s|usage-indicator_${VERSION_NO_V}_arm64-setup\.exe|usage-indicator-${VERSION}-${PLATFORM}-aarch64.exe|g" \
                -e "s|usage-indicator_${VERSION_NO_V}_arm64_en-US\.msi|usage-indicator-${VERSION}-${PLATFORM}-aarch64.msi|g" \
                "latest.json.tmp"
            elif [ "$OS" = "macos" ]; then
              sed -i.bak \
                -e "s|usage-indicator_${VERSION_NO_V}_x64\.dmg|usage-indicator-${VERSION}-${PLATFORM}-x86_64.dmg|g" \
                -e "s|usage-indicator_${VERSION_NO_V}_aarch64\.dmg|usage-indicator-${VERSION}-${PLATFORM}-aarch64.dmg|g" \
                "latest.json.tmp"
            elif [ "$OS" = "linux" ]; then
              sed -i.bak \
                -e "s|usage-indicator_${VERSION_NO_V}_amd64\.AppImage|usage-indicator-${VERSION}-${PLATFORM}-x86_64.AppImage|g" \
                "latest.json.tmp"
            fi

            mv "latest.json.tmp" "latest.json"
            rm -f "latest.json.tmp.bak"
            RENAMED_FILES+=("latest.json")
          fi

          # Save file list for next step
          printf "%s\n" "${RENAMED_FILES[@]}" > renamed_files.txt

          # Also save as GitHub output for upload step
          echo "files<<EOF" >> $GITHUB_OUTPUT
          printf "%s\n" "${RENAMED_FILES[@]}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload artifacts to GitHub release
        id: upload-release
        if: github.event_name == 'push' && github.ref_type == 'tag'
        shell: bash
        run: |
          if [ -f renamed_files.txt ]; then
            while IFS= read -r file; do
              if [ -f "$file" ]; then
                echo "Uploading $file to release..."
                gh release upload "${{ github.ref_name }}" "$file" --clobber
              fi
            done < renamed_files.txt
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts (dry run)
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.target.os }}-${{ matrix.target.arch }}
          path: |
            *.AppImage
            *.dmg
            *.exe
            *.msi
            *.sig
            latest.json
          if-no-files-found: warn
          retention-days: 7

      - name: Generate build provenance attestations
        if: github.event.repository.fork == false && github.ref_type == 'tag'
        continue-on-error: true
        shell: bash
        run: |
          if [ -f renamed_files.txt ]; then
            while IFS= read -r file; do
              if [ -f "$file" ] && [[ ! "$file" == *.sig ]] && [[ ! "$file" == *.json ]]; then
                echo "Generating attestation for $file..."
                gh attestation attest "$file" --owner ${{ github.repository_owner }} || true
              fi
            done < renamed_files.txt
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
